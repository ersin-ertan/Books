package A_GettingStartedWithParsing.A_LanguageApplicationsCrackedOpen

// Dissecting a few applications
// Bit like fractals, zoom into architecture to se pipeline stages are multistage pipelines
// Data structs and algorithms are reused across applications and stages.

//Bytecode interpreter
// bytecode file -> (bytes) -> Reader to load bytecode via symbol table -> interpreter to fetch, execute cycle -> program result

// Interpreter is a program that executes other programs, simulating a hardware processor in software(virtual machines)
// Low level, but higher than machine code, called bytecodes because each instruction can be represented with a unique
// integer code from 0..255(byte range)

// Java uses register based bytecode interpreter, others use stack based. Java bug finding self assignment bug.
// java code -> reader to parse, build IR -> semantic analyzer to define symbols, find bugs -> generator for report -> bug report

class Point{
    private var x:Int = 0
    private var y:Int = 0
    fun setX(y:Int){this.x = x} // not actually setting x, just reasigging
    fun setY(y:Int){this.y = y}
}

// Start with end in mind, figure out what you need to generate the output, then work backwards.
// We need to track all symbol definitions using a symbol table. To parse Java we use a pattern call LL(1) Recursive
// Descent lexer, LL(k) recursive descent parser, Backtracking Parser, Memoizing Parser. Simple IR, using Homogeneous AST.


// Two stage process, first stage to break up character stream into vocabulary symbols called tokens. THe parser feeds off these
// tokens to check syntax. The tokenizer/lexer yield a stream of vocabulary symbols
// void setX(int y){ ... as the parser checks the syntax, it builds the IR. We need an IR because of multiple passes over
// input. Retokenizing and reparsing the text input for every pass is inefficient and marder to pass info between stages.
// Multiple passes support forward references, see field x even if it is defined after method setX. Define symbols first
// before resolution, to see bug x easily.

// We have have a list of Bug objects, our generator print them with a for loop. Complicated reports require a template.
// Bug has fields, file, line, fieldname, we can use two StringTemplate templates definitions to generate a report(see
// template syntax via Generating DSLs with Templates). Pass the list of Bug objects to the report template as attribute bugs,
// StringTemplate does rest.
//

// Java bug finding part deux
// Or another way to implement the bug finding is via javac which generates .class files containing serialized versions
// of symbol table and AST. Use Byte code engineering library BCEL, or a class file reader to load .class files(findBugs
// uses this.
// java .class file -> (bytes) -> Reader, semantic analyzer loads bycodes > finds bugs -> Generator gens report -> bug report

// Dont need source code parser, nor built symbol table, since javac has resolved all symbols and generated bytecode that
// refers to unique program entities. Look for a particular bytecode sequence,

/*
* 0: aload_0 // push this onto stack
* 1: aload_0 // push this onto stack
* 2: getfield #3; // push field this.x onto stack
* 5: putfield #3; // store top of stack (this.x) into field this.x
* 8: return
* */

// #2 operand is an offest into the symbol table and uniquelly identifies the x field symbol. Bytecode gets and puts the
// same field. If this.x referred to a different field than x, a different symbol number as operands of getfield and putfield
// would appear. Compilation process feeds this to bug finder. javac is a compiler, like C compiler(C translates programs down
// to instructions running natively on particular CPU)


// C Compiler
// looks like on big program with single ccommand to launch(cc or gcc. Complicated compilation process with lots of components.
// First preprocess C files to handle includes macros. Spit out pure C with line number directives for compiler. Then
// compiler outputs assembly code, another assembler translates assembly code to binary machine code, a few command line options
// can expose the pipeline. C compilation process pipeline
// C code -> pre procecssor -> (C) -> compiler -> (assembly code) -> assembler -> machine code

// Isolated C compiler application pipeline
// C code -> Compiler[ [reader parses, build IR] -> [Semantic Analyzer defines symbol, verify semantics, optimize...] ->
// [Generator gens assembly] end compiler ] -> assembly code

// Hard to understand happens inside the semantic analyyzer and optimizer, which builds extra data structs from IR
// to produce efficient version of input C program in assembly code. Set and graph theory algorithms are at work. Leverage
// an existing compiler to implement a higher language one.

// C++ code -> pre processor -> (c++) -> C++ to c translator(cfront) -> C -> C compilation pipeline -> machine code
// Bjarne Stroustrup built a C++ to C translator called cfront, no compiler built, it generated C